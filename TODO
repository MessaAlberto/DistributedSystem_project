- Gestire timeout di join/recover: il nodo che fa l'azione ha un timeout che si avvia alla richiesta da parte del testManager. Il timeout viene cancellato quando l'azione è conclusa, cioè quando invia la risposta al testManager.

JOIN possibili timeout:
- il bootstrap risponde sempre, per assunzione è un nodo non crashato, la rispsota deve arrivare sempre prima del timeout
- il nodo sucessivo potrebbe essere crashato e visto che la crash detection non ci compete, il nodo che fa il join non riceverebbe risposta e scatta il timeout
- durante il maintenanceReads (richieste di reads per ogni key): ogni richiesta deve raggiungere il quorum per considerarsi consistente. Quindi se anche una sola richiesta NON raggiunge il quorum entro il timeout, allora tutta l'azione di join fallirebbe. Il nodo lo comunica al testManager e non c'è altro da sistemare.

L'azione si può ritenere conclusa quando tutte le read di maintenance sono complete, quindi in completeMaintenanceIfDone si può cancellare il timeout e poi annunciare a tutti nodi il join nella rete.

RECOVER possibili timeout:
- esattamente come il JOIN
- unica differenza è che per ottenere tutte le chiavi necessarie, il nodo deve contattare il suo sucessore e predecessore. Quindi se non riceve rispsota da uno dei due in tempo, scatta il timeout.


Possibilmente fare in modo che in caso di timeout, il nodo riferisca in che punto dell'operazione si è bloccato. Così il testManager può printare un messaggio più preciso (aiuta a capire se in certi scenari, i test falliscono come noi ci aspettavamo)